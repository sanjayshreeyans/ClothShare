{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport { CodedError, RCTDeviceEventEmitter, UnavailabilityError } from '@unimodules/core';\nimport Constants from 'expo-constants';\nimport { EventEmitter } from 'fbemitter';\nimport invariant from 'invariant';\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport ExponentNotifications from \"./ExponentNotifications\";\nimport Storage from \"./Storage\";\n\nvar _emitter;\n\nvar _initialNotification;\n\nfunction _maybeInitEmitter() {\n  if (!_emitter) {\n    _emitter = new EventEmitter();\n    RCTDeviceEventEmitter.addListener('Exponent.notification', emitNotification);\n  }\n}\n\nexport function emitNotification(notification) {\n  if (typeof notification === 'string') {\n    notification = JSON.parse(notification);\n  }\n\n  notification = _objectSpread({}, notification);\n\n  if (typeof notification.data === 'string') {\n    try {\n      notification.data = JSON.parse(notification.data);\n    } catch (e) {}\n  }\n\n  _emitter.emit('notification', notification);\n}\n\nfunction _processNotification(notification) {\n  notification = _extends({}, notification);\n\n  if (!notification.data) {\n    notification.data = {};\n  }\n\n  if (notification.hasOwnProperty('count')) {\n    delete notification.count;\n  }\n\n  if (Platform.OS === 'ios') {\n    if (notification.android) {\n      delete notification.android;\n    }\n\n    if (notification.ios) {\n      notification = _extends(notification, notification.ios);\n      notification.data._displayInForeground = notification.ios._displayInForeground;\n      delete notification.ios;\n    }\n  }\n\n  if (Platform.OS === 'android') {\n    if (notification.ios) {\n      delete notification.ios;\n    }\n\n    if (notification.android) {\n      notification = _extends(notification, notification.android);\n      delete notification.android;\n    }\n  }\n\n  return notification;\n}\n\nfunction _validateNotification(notification) {\n  if (Platform.OS === 'ios') {\n    invariant(!!notification.title && !!notification.body, 'Local notifications on iOS require both a title and a body');\n  } else if (Platform.OS === 'android') {\n    invariant(!!notification.title, 'Local notifications on Android require a title');\n  }\n}\n\nvar ASYNC_STORAGE_PREFIX = '__expo_internal_channel_';\nvar IS_USING_NEW_BINARY = ExponentNotifications && typeof ExponentNotifications.createChannel === 'function';\n\nfunction _legacyReadChannel(id) {\n  var channelString;\n  return _regeneratorRuntime.async(function _legacyReadChannel$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.prev = 0;\n          _context.next = 3;\n          return _regeneratorRuntime.awrap(Storage.getItem(\"\" + ASYNC_STORAGE_PREFIX + id));\n\n        case 3:\n          channelString = _context.sent;\n\n          if (!channelString) {\n            _context.next = 6;\n            break;\n          }\n\n          return _context.abrupt(\"return\", JSON.parse(channelString));\n\n        case 6:\n          _context.next = 10;\n          break;\n\n        case 8:\n          _context.prev = 8;\n          _context.t0 = _context[\"catch\"](0);\n\n        case 10:\n          return _context.abrupt(\"return\", null);\n\n        case 11:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[0, 8]], Promise);\n}\n\nfunction _legacyDeleteChannel(id) {\n  return Storage.removeItem(\"\" + ASYNC_STORAGE_PREFIX + id);\n}\n\nif (Platform.OS === 'android') {\n  Storage.clear = function _callee(callback) {\n    var keys, filteredKeys;\n    return _regeneratorRuntime.async(function _callee$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            _context2.next = 3;\n            return _regeneratorRuntime.awrap(Storage.getAllKeys());\n\n          case 3:\n            keys = _context2.sent;\n\n            if (!(keys && keys.length)) {\n              _context2.next = 8;\n              break;\n            }\n\n            filteredKeys = keys.filter(function (key) {\n              return !key.startsWith(ASYNC_STORAGE_PREFIX);\n            });\n            _context2.next = 8;\n            return _regeneratorRuntime.awrap(Storage.multiRemove(filteredKeys));\n\n          case 8:\n            callback && callback();\n            _context2.next = 15;\n            break;\n\n          case 11:\n            _context2.prev = 11;\n            _context2.t0 = _context2[\"catch\"](0);\n            callback && callback(_context2.t0);\n            throw _context2.t0;\n\n          case 15:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, [[0, 11]], Promise);\n  };\n}\n\nfunction _legacySaveChannel(id, channel) {\n  return Storage.setItem(\"\" + ASYNC_STORAGE_PREFIX + id, JSON.stringify(channel));\n}\n\nexport default {\n  _setInitialNotification: function _setInitialNotification(notification) {\n    _initialNotification = notification;\n  },\n  createCategoryAsync: function createCategoryAsync(categoryId, actions, previewPlaceholder) {\n    return Platform.OS === 'ios' ? ExponentNotifications.createCategoryAsync(categoryId, actions, previewPlaceholder) : ExponentNotifications.createCategoryAsync(categoryId, actions);\n  },\n  deleteCategoryAsync: function deleteCategoryAsync(categoryId) {\n    return ExponentNotifications.deleteCategoryAsync(categoryId);\n  },\n  getExpoPushTokenAsync: function getExpoPushTokenAsync() {\n    if (!ExponentNotifications.getExponentPushTokenAsync) {\n      throw new UnavailabilityError('Expo.Notifications', 'getExpoPushTokenAsync');\n    }\n\n    if (!Constants.isDevice) {\n      throw new Error(\"Must be on a physical device to get an Expo Push Token\");\n    }\n\n    return ExponentNotifications.getExponentPushTokenAsync();\n  },\n  getDevicePushTokenAsync: function getDevicePushTokenAsync(config) {\n    if (!ExponentNotifications.getDevicePushTokenAsync) {\n      throw new UnavailabilityError('Expo.Notifications', 'getDevicePushTokenAsync');\n    }\n\n    return ExponentNotifications.getDevicePushTokenAsync(config || {});\n  },\n  createChannelAndroidAsync: function createChannelAndroidAsync(id, channel) {\n    if (Platform.OS !== 'android') {\n      console.warn(\"createChannelAndroidAsync(...) has no effect on \" + Platform.OS);\n      return Promise.resolve();\n    }\n\n    if (!IS_USING_NEW_BINARY) {\n      return _legacySaveChannel(id, channel);\n    }\n\n    return ExponentNotifications.createChannel(id, channel);\n  },\n  deleteChannelAndroidAsync: function deleteChannelAndroidAsync(id) {\n    if (Platform.OS !== 'android') {\n      console.warn(\"deleteChannelAndroidAsync(...) has no effect on \" + Platform.OS);\n      return Promise.resolve();\n    }\n\n    if (!IS_USING_NEW_BINARY) {\n      return Promise.resolve();\n    }\n\n    return ExponentNotifications.deleteChannel(id);\n  },\n  presentLocalNotificationAsync: function presentLocalNotificationAsync(notification) {\n    var nativeNotification, _channel;\n\n    return _regeneratorRuntime.async(function presentLocalNotificationAsync$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _validateNotification(notification);\n\n            nativeNotification = _processNotification(notification);\n\n            if (!(Platform.OS !== 'android')) {\n              _context3.next = 8;\n              break;\n            }\n\n            _context3.next = 5;\n            return _regeneratorRuntime.awrap(ExponentNotifications.presentLocalNotification(nativeNotification));\n\n          case 5:\n            return _context3.abrupt(\"return\", _context3.sent);\n\n          case 8:\n            if (!nativeNotification.channelId) {\n              _context3.next = 12;\n              break;\n            }\n\n            _context3.next = 11;\n            return _regeneratorRuntime.awrap(_legacyReadChannel(nativeNotification.channelId));\n\n          case 11:\n            _channel = _context3.sent;\n\n          case 12:\n            if (!IS_USING_NEW_BINARY) {\n              _context3.next = 17;\n              break;\n            }\n\n            _legacyDeleteChannel(nativeNotification.channelId);\n\n            return _context3.abrupt(\"return\", ExponentNotifications.presentLocalNotificationWithChannel(nativeNotification, _channel));\n\n          case 17:\n            if (_channel) {\n              nativeNotification.sound = _channel.sound;\n              nativeNotification.priority = _channel.priority;\n              nativeNotification.vibrate = _channel.vibrate;\n            }\n\n            return _context3.abrupt(\"return\", ExponentNotifications.presentLocalNotification(nativeNotification));\n\n          case 19:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  scheduleLocalNotificationAsync: function scheduleLocalNotificationAsync(notification) {\n    var options,\n        now,\n        nativeNotification,\n        timeAsDateObj,\n        validOptions,\n        _channel,\n        _args4 = arguments;\n\n    return _regeneratorRuntime.async(function scheduleLocalNotificationAsync$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            options = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};\n            now = Date.now();\n\n            _validateNotification(notification);\n\n            nativeNotification = _processNotification(notification);\n\n            if (!options.time) {\n              _context4.next = 11;\n              break;\n            }\n\n            timeAsDateObj = null;\n\n            if (options.time && typeof options.time === 'number') {\n              timeAsDateObj = new Date(options.time);\n\n              if (timeAsDateObj.toString() === 'Invalid Date') {\n                timeAsDateObj = null;\n              }\n            } else if (options.time && options.time instanceof Date) {\n              timeAsDateObj = options.time;\n            }\n\n            if (timeAsDateObj) {\n              _context4.next = 9;\n              break;\n            }\n\n            throw new Error(\"Provided value for \\\"time\\\" is invalid. Please verify that it's either a number representing Unix Epoch time in milliseconds, or a valid date object.\");\n\n          case 9:\n            if (timeAsDateObj.getTime() < now) {\n              console.warn(\"Provided value for \\\"time\\\" is before the current date. Did you possibly pass number of seconds since Unix Epoch instead of number of milliseconds?\");\n            }\n\n            options = _objectSpread(_objectSpread({}, options), {}, {\n              time: timeAsDateObj.getTime()\n            });\n\n          case 11:\n            if (!(options.intervalMs != null && options.repeat != null)) {\n              _context4.next = 13;\n              break;\n            }\n\n            throw new Error(\"Pass either the \\\"repeat\\\" option or \\\"intervalMs\\\" option, not both\");\n\n          case 13:\n            if (!(options.repeat != null)) {\n              _context4.next = 17;\n              break;\n            }\n\n            validOptions = new Set(['minute', 'hour', 'day', 'week', 'month', 'year']);\n\n            if (validOptions.has(options.repeat)) {\n              _context4.next = 17;\n              break;\n            }\n\n            throw new Error(\"Pass one of ['minute', 'hour', 'day', 'week', 'month', 'year'] as the value for the \\\"repeat\\\" option\");\n\n          case 17:\n            if (!(options.intervalMs != null)) {\n              _context4.next = 22;\n              break;\n            }\n\n            if (!(Platform.OS === 'ios')) {\n              _context4.next = 20;\n              break;\n            }\n\n            throw new Error(\"The \\\"intervalMs\\\" option is not supported on iOS\");\n\n          case 20:\n            if (!(options.intervalMs <= 0 || !Number.isInteger(options.intervalMs))) {\n              _context4.next = 22;\n              break;\n            }\n\n            throw new Error(\"Pass an integer greater than zero as the value for the \\\"intervalMs\\\" option\");\n\n          case 22:\n            if (!(Platform.OS !== 'android')) {\n              _context4.next = 29;\n              break;\n            }\n\n            if (!options.repeat) {\n              _context4.next = 26;\n              break;\n            }\n\n            console.warn('Ability to schedule an automatically repeated notification is deprecated on iOS and will be removed in the next SDK release.');\n            return _context4.abrupt(\"return\", ExponentNotifications.legacyScheduleLocalRepeatingNotification(nativeNotification, options));\n\n          case 26:\n            return _context4.abrupt(\"return\", ExponentNotifications.scheduleLocalNotification(nativeNotification, options));\n\n          case 29:\n            if (!nativeNotification.channelId) {\n              _context4.next = 33;\n              break;\n            }\n\n            _context4.next = 32;\n            return _regeneratorRuntime.awrap(_legacyReadChannel(nativeNotification.channelId));\n\n          case 32:\n            _channel = _context4.sent;\n\n          case 33:\n            if (!IS_USING_NEW_BINARY) {\n              _context4.next = 38;\n              break;\n            }\n\n            _legacyDeleteChannel(nativeNotification.channelId);\n\n            return _context4.abrupt(\"return\", ExponentNotifications.scheduleLocalNotificationWithChannel(nativeNotification, options, _channel));\n\n          case 38:\n            if (_channel) {\n              nativeNotification.sound = _channel.sound;\n              nativeNotification.priority = _channel.priority;\n              nativeNotification.vibrate = _channel.vibrate;\n            }\n\n            return _context4.abrupt(\"return\", ExponentNotifications.scheduleLocalNotification(nativeNotification, options));\n\n          case 40:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  dismissNotificationAsync: function dismissNotificationAsync(notificationId) {\n    return _regeneratorRuntime.async(function dismissNotificationAsync$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            if (ExponentNotifications.dismissNotification) {\n              _context5.next = 2;\n              break;\n            }\n\n            throw new UnavailabilityError('Expo.Notifications', 'dismissNotification');\n\n          case 2:\n            _context5.next = 4;\n            return _regeneratorRuntime.awrap(ExponentNotifications.dismissNotification(notificationId));\n\n          case 4:\n            return _context5.abrupt(\"return\", _context5.sent);\n\n          case 5:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  dismissAllNotificationsAsync: function dismissAllNotificationsAsync() {\n    return _regeneratorRuntime.async(function dismissAllNotificationsAsync$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            if (ExponentNotifications.dismissAllNotifications) {\n              _context6.next = 2;\n              break;\n            }\n\n            throw new UnavailabilityError('Expo.Notifications', 'dismissAllNotifications');\n\n          case 2:\n            _context6.next = 4;\n            return _regeneratorRuntime.awrap(ExponentNotifications.dismissAllNotifications());\n\n          case 4:\n            return _context6.abrupt(\"return\", _context6.sent);\n\n          case 5:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  cancelScheduledNotificationAsync: function cancelScheduledNotificationAsync(notificationId) {\n    if (Platform.OS === 'android' && typeof notificationId === 'string') {\n      return ExponentNotifications.cancelScheduledNotificationWithStringIdAsync(notificationId);\n    }\n\n    return ExponentNotifications.cancelScheduledNotificationAsync(notificationId);\n  },\n  cancelAllScheduledNotificationsAsync: function cancelAllScheduledNotificationsAsync() {\n    return ExponentNotifications.cancelAllScheduledNotificationsAsync();\n  },\n  addListener: function addListener(listener) {\n    _maybeInitEmitter();\n\n    if (_initialNotification) {\n      var initialNotification = _initialNotification;\n      _initialNotification = null;\n      setTimeout(function () {\n        emitNotification(initialNotification);\n      }, 0);\n    }\n\n    return _emitter.addListener('notification', listener);\n  },\n  getBadgeNumberAsync: function getBadgeNumberAsync() {\n    return _regeneratorRuntime.async(function getBadgeNumberAsync$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            if (ExponentNotifications.getBadgeNumberAsync) {\n              _context7.next = 2;\n              break;\n            }\n\n            return _context7.abrupt(\"return\", 0);\n\n          case 2:\n            return _context7.abrupt(\"return\", ExponentNotifications.getBadgeNumberAsync());\n\n          case 3:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  setBadgeNumberAsync: function setBadgeNumberAsync(number) {\n    return _regeneratorRuntime.async(function setBadgeNumberAsync$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            if (ExponentNotifications.setBadgeNumberAsync) {\n              _context8.next = 2;\n              break;\n            }\n\n            throw new UnavailabilityError('Expo.Notifications', 'setBadgeNumberAsync');\n\n          case 2:\n            return _context8.abrupt(\"return\", ExponentNotifications.setBadgeNumberAsync(number));\n\n          case 3:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  scheduleNotificationWithCalendarAsync: function scheduleNotificationWithCalendarAsync(notification) {\n    var options,\n        areOptionsValid,\n        nativeNotification,\n        _args9 = arguments;\n    return _regeneratorRuntime.async(function scheduleNotificationWithCalendarAsync$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            options = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : {};\n            areOptionsValid = (options.month == null || isInRangeInclusive(options.month, 1, 12)) && (options.day == null || isInRangeInclusive(options.day, 1, 31)) && (options.hour == null || isInRangeInclusive(options.hour, 0, 23)) && (options.minute == null || isInRangeInclusive(options.minute, 0, 59)) && (options.second == null || isInRangeInclusive(options.second, 0, 59)) && (options.weekDay == null || isInRangeInclusive(options.weekDay, 1, 7)) && (options.weekDay == null || options.day == null);\n\n            if (areOptionsValid) {\n              _context9.next = 4;\n              break;\n            }\n\n            throw new CodedError('WRONG_OPTIONS', 'Options in scheduleNotificationWithCalendarAsync call were incorrect!');\n\n          case 4:\n            _validateNotification(notification);\n\n            nativeNotification = _processNotification(notification);\n            return _context9.abrupt(\"return\", ExponentNotifications.scheduleNotificationWithCalendar(nativeNotification, options));\n\n          case 7:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  scheduleNotificationWithTimerAsync: function scheduleNotificationWithTimerAsync(notification, options) {\n    var nativeNotification;\n    return _regeneratorRuntime.async(function scheduleNotificationWithTimerAsync$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            if (!(options.interval < 1)) {\n              _context10.next = 2;\n              break;\n            }\n\n            throw new CodedError('WRONG_OPTIONS', 'Interval must be not less then 1');\n\n          case 2:\n            _validateNotification(notification);\n\n            nativeNotification = _processNotification(notification);\n            return _context10.abrupt(\"return\", ExponentNotifications.scheduleNotificationWithTimer(nativeNotification, options));\n\n          case 5:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }\n};\n\nfunction isInRangeInclusive(variable, min, max) {\n  return variable >= min && variable <= max;\n}","map":{"version":3,"mappings":"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","names":["CodedError","RCTDeviceEventEmitter","UnavailabilityError","Constants","EventEmitter","invariant","ExponentNotifications","Storage","_emitter","_initialNotification","_maybeInitEmitter","addListener","emitNotification","notification","JSON","parse","data","e","emit","_processNotification","hasOwnProperty","count","Platform","OS","android","ios","_displayInForeground","_validateNotification","title","body","ASYNC_STORAGE_PREFIX","IS_USING_NEW_BINARY","createChannel","_legacyReadChannel","id","getItem","channelString","_legacyDeleteChannel","removeItem","clear","callback","getAllKeys","keys","length","filteredKeys","filter","key","startsWith","multiRemove","_legacySaveChannel","channel","setItem","stringify","_setInitialNotification","createCategoryAsync","categoryId","actions","previewPlaceholder","deleteCategoryAsync","getExpoPushTokenAsync","getExponentPushTokenAsync","isDevice","Error","getDevicePushTokenAsync","config","createChannelAndroidAsync","console","warn","Promise","resolve","deleteChannelAndroidAsync","deleteChannel","presentLocalNotificationAsync","nativeNotification","presentLocalNotification","channelId","_channel","presentLocalNotificationWithChannel","sound","priority","vibrate","scheduleLocalNotificationAsync","options","now","Date","time","timeAsDateObj","toString","getTime","intervalMs","repeat","validOptions","Set","has","Number","isInteger","legacyScheduleLocalRepeatingNotification","scheduleLocalNotification","scheduleLocalNotificationWithChannel","dismissNotificationAsync","notificationId","dismissNotification","dismissAllNotificationsAsync","dismissAllNotifications","cancelScheduledNotificationAsync","cancelScheduledNotificationWithStringIdAsync","cancelAllScheduledNotificationsAsync","listener","initialNotification","setTimeout","getBadgeNumberAsync","setBadgeNumberAsync","number","scheduleNotificationWithCalendarAsync","areOptionsValid","month","isInRangeInclusive","day","hour","minute","second","weekDay","scheduleNotificationWithCalendar","scheduleNotificationWithTimerAsync","interval","scheduleNotificationWithTimer","variable","min","max"],"sourceRoot":"","sources":["../../src/Notifications/Notifications.ts"],"sourcesContent":["import { CodedError, RCTDeviceEventEmitter, UnavailabilityError } from '@unimodules/core';\nimport Constants from 'expo-constants';\nimport { EventEmitter, EventSubscription } from 'fbemitter';\nimport invariant from 'invariant';\nimport { Platform } from 'react-native';\n\nimport ExponentNotifications from './ExponentNotifications';\nimport {\n  Notification,\n  LocalNotification,\n  Channel,\n  ActionType,\n  LocalNotificationId,\n} from './Notifications.types';\nimport Storage from './Storage';\n\nlet _emitter;\nlet _initialNotification;\n\nfunction _maybeInitEmitter() {\n  if (!_emitter) {\n    _emitter = new EventEmitter();\n    RCTDeviceEventEmitter.addListener('Exponent.notification', emitNotification);\n  }\n}\n\nexport function emitNotification(notification) {\n  if (typeof notification === 'string') {\n    notification = JSON.parse(notification);\n  }\n\n  /* Don't mutate the original notification */\n  notification = { ...notification };\n\n  if (typeof notification.data === 'string') {\n    try {\n      notification.data = JSON.parse(notification.data);\n    } catch (e) {\n      // It's actually just a string, that's fine\n    }\n  }\n\n  _emitter.emit('notification', notification);\n}\n\nfunction _processNotification(notification) {\n  notification = Object.assign({}, notification);\n\n  if (!notification.data) {\n    notification.data = {};\n  }\n\n  if (notification.hasOwnProperty('count')) {\n    delete notification.count;\n  }\n\n  // Delete any Android properties on iOS and merge the iOS properties on root notification object\n  if (Platform.OS === 'ios') {\n    if (notification.android) {\n      delete notification.android;\n    }\n\n    if (notification.ios) {\n      notification = Object.assign(notification, notification.ios);\n      notification.data._displayInForeground = notification.ios._displayInForeground;\n      delete notification.ios;\n    }\n  }\n\n  // Delete any iOS properties on Android and merge the Android properties on root notification\n  // object\n  if (Platform.OS === 'android') {\n    if (notification.ios) {\n      delete notification.ios;\n    }\n\n    if (notification.android) {\n      notification = Object.assign(notification, notification.android);\n      delete notification.android;\n    }\n  }\n\n  return notification;\n}\n\nfunction _validateNotification(notification) {\n  if (Platform.OS === 'ios') {\n    invariant(\n      !!notification.title && !!notification.body,\n      'Local notifications on iOS require both a title and a body'\n    );\n  } else if (Platform.OS === 'android') {\n    invariant(!!notification.title, 'Local notifications on Android require a title');\n  }\n}\n\nconst ASYNC_STORAGE_PREFIX = '__expo_internal_channel_';\n// TODO: remove this before releasing\n// this will always be `true` for SDK 28+\nconst IS_USING_NEW_BINARY =\n  ExponentNotifications && typeof ExponentNotifications.createChannel === 'function';\n\nasync function _legacyReadChannel(id: string): Promise<Channel | null> {\n  try {\n    const channelString = await Storage.getItem(`${ASYNC_STORAGE_PREFIX}${id}`);\n    if (channelString) {\n      return JSON.parse(channelString);\n    }\n  } catch (e) {}\n  return null;\n}\n\nfunction _legacyDeleteChannel(id: string): Promise<void> {\n  return Storage.removeItem(`${ASYNC_STORAGE_PREFIX}${id}`);\n}\n\nif (Platform.OS === 'android') {\n  Storage.clear = async function(callback?: (error?: Error) => void): Promise<void> {\n    try {\n      const keys = await Storage.getAllKeys();\n      if (keys && keys.length) {\n        const filteredKeys = keys.filter(key => !key.startsWith(ASYNC_STORAGE_PREFIX));\n        await Storage.multiRemove(filteredKeys);\n      }\n      callback && callback();\n    } catch (e) {\n      callback && callback(e);\n      throw e;\n    }\n  };\n}\n\n// This codepath will never be triggered in SDK 28 and above\n// TODO: remove before releasing\nfunction _legacySaveChannel(id: string, channel: Channel): Promise<void> {\n  return Storage.setItem(`${ASYNC_STORAGE_PREFIX}${id}`, JSON.stringify(channel));\n}\n\nexport default {\n  /* Only used internally to initialize the notification from top level props */\n  _setInitialNotification(notification: Notification) {\n    _initialNotification = notification;\n  },\n\n  // User passes set of actions titles.\n  createCategoryAsync(\n    categoryId: string,\n    actions: ActionType[],\n    previewPlaceholder?: string\n  ): Promise<void> {\n    return Platform.OS === 'ios'\n      ? ExponentNotifications.createCategoryAsync(categoryId, actions, previewPlaceholder)\n      : ExponentNotifications.createCategoryAsync(categoryId, actions);\n  },\n\n  deleteCategoryAsync(categoryId: string): Promise<void> {\n    return ExponentNotifications.deleteCategoryAsync(categoryId);\n  },\n\n  /* Re-export */\n  getExpoPushTokenAsync(): Promise<string> {\n    if (!ExponentNotifications.getExponentPushTokenAsync) {\n      throw new UnavailabilityError('Expo.Notifications', 'getExpoPushTokenAsync');\n    }\n    if (!Constants.isDevice) {\n      throw new Error(`Must be on a physical device to get an Expo Push Token`);\n    }\n    return ExponentNotifications.getExponentPushTokenAsync();\n  },\n\n  getDevicePushTokenAsync: (config: {\n    gcmSenderId?: string;\n  }): Promise<{ type: string; data: string }> => {\n    if (!ExponentNotifications.getDevicePushTokenAsync) {\n      throw new UnavailabilityError('Expo.Notifications', 'getDevicePushTokenAsync');\n    }\n    return ExponentNotifications.getDevicePushTokenAsync(config || {});\n  },\n\n  createChannelAndroidAsync(id: string, channel: Channel): Promise<void> {\n    if (Platform.OS !== 'android') {\n      console.warn(`createChannelAndroidAsync(...) has no effect on ${Platform.OS}`);\n      return Promise.resolve();\n    }\n    // This codepath will never be triggered in SDK 28 and above\n    // TODO: remove before releasing\n    if (!IS_USING_NEW_BINARY) {\n      return _legacySaveChannel(id, channel);\n    }\n    return ExponentNotifications.createChannel(id, channel);\n  },\n\n  deleteChannelAndroidAsync(id: string): Promise<void> {\n    if (Platform.OS !== 'android') {\n      console.warn(`deleteChannelAndroidAsync(...) has no effect on ${Platform.OS}`);\n      return Promise.resolve();\n    }\n    // This codepath will never be triggered in SDK 28 and above\n    // TODO: remove before releasing\n    if (!IS_USING_NEW_BINARY) {\n      return Promise.resolve();\n    }\n    return ExponentNotifications.deleteChannel(id);\n  },\n\n  /* Shows a notification instantly */\n  async presentLocalNotificationAsync(\n    notification: LocalNotification\n  ): Promise<LocalNotificationId> {\n    _validateNotification(notification);\n    const nativeNotification = _processNotification(notification);\n\n    if (Platform.OS !== 'android') {\n      return await ExponentNotifications.presentLocalNotification(nativeNotification);\n    } else {\n      let _channel;\n      if (nativeNotification.channelId) {\n        _channel = await _legacyReadChannel(nativeNotification.channelId);\n      }\n\n      if (IS_USING_NEW_BINARY) {\n        // delete the legacy channel from AsyncStorage so this codepath isn't triggered anymore\n        _legacyDeleteChannel(nativeNotification.channelId);\n        return ExponentNotifications.presentLocalNotificationWithChannel(\n          nativeNotification,\n          _channel\n        );\n      } else {\n        // TODO: remove this codepath before releasing, it will never be triggered on SDK 28+\n        // channel does not actually exist, so add its settings to the individual notification\n        if (_channel) {\n          nativeNotification.sound = _channel.sound;\n          nativeNotification.priority = _channel.priority;\n          nativeNotification.vibrate = _channel.vibrate;\n        }\n        return ExponentNotifications.presentLocalNotification(nativeNotification);\n      }\n    }\n  },\n\n  /* Schedule a notification at a later date */\n  async scheduleLocalNotificationAsync(\n    notification: LocalNotification,\n    options: {\n      time?: Date | number;\n      repeat?: 'minute' | 'hour' | 'day' | 'week' | 'month' | 'year';\n      intervalMs?: number;\n    } = {}\n  ): Promise<LocalNotificationId> {\n    // set now at the beginning of the method, to prevent potential weird warnings when we validate\n    // options.time later on\n    const now = Date.now();\n\n    // Validate and process the notification data\n    _validateNotification(notification);\n    const nativeNotification = _processNotification(notification);\n\n    // Validate `options.time`\n    if (options.time) {\n      let timeAsDateObj: Date | null = null;\n      if (options.time && typeof options.time === 'number') {\n        timeAsDateObj = new Date(options.time);\n        if (timeAsDateObj.toString() === 'Invalid Date') {\n          timeAsDateObj = null;\n        }\n      } else if (options.time && options.time instanceof Date) {\n        timeAsDateObj = options.time;\n      }\n\n      // If we couldn't convert properly, throw an error\n      if (!timeAsDateObj) {\n        throw new Error(\n          `Provided value for \"time\" is invalid. Please verify that it's either a number representing Unix Epoch time in milliseconds, or a valid date object.`\n        );\n      }\n\n      // If someone passes in a value that is too small, say, by an order of 1000 (it's common to\n      // accidently pass seconds instead of ms), display a warning.\n      if (timeAsDateObj.getTime() < now) {\n        console.warn(\n          `Provided value for \"time\" is before the current date. Did you possibly pass number of seconds since Unix Epoch instead of number of milliseconds?`\n        );\n      }\n\n      options = {\n        ...options,\n        time: timeAsDateObj.getTime(),\n      };\n    }\n\n    if (options.intervalMs != null && options.repeat != null) {\n      throw new Error(`Pass either the \"repeat\" option or \"intervalMs\" option, not both`);\n    }\n\n    // Validate options.repeat\n    if (options.repeat != null) {\n      const validOptions = new Set(['minute', 'hour', 'day', 'week', 'month', 'year']);\n      if (!validOptions.has(options.repeat)) {\n        throw new Error(\n          `Pass one of ['minute', 'hour', 'day', 'week', 'month', 'year'] as the value for the \"repeat\" option`\n        );\n      }\n    }\n\n    if (options.intervalMs != null) {\n      if (Platform.OS === 'ios') {\n        throw new Error(`The \"intervalMs\" option is not supported on iOS`);\n      }\n\n      if (options.intervalMs <= 0 || !Number.isInteger(options.intervalMs)) {\n        throw new Error(\n          `Pass an integer greater than zero as the value for the \"intervalMs\" option`\n        );\n      }\n    }\n\n    if (Platform.OS !== 'android') {\n      if (options.repeat) {\n        console.warn(\n          'Ability to schedule an automatically repeated notification is deprecated on iOS and will be removed in the next SDK release.'\n        );\n        return ExponentNotifications.legacyScheduleLocalRepeatingNotification(\n          nativeNotification,\n          options\n        );\n      }\n\n      return ExponentNotifications.scheduleLocalNotification(nativeNotification, options);\n    } else {\n      let _channel;\n      if (nativeNotification.channelId) {\n        _channel = await _legacyReadChannel(nativeNotification.channelId);\n      }\n\n      if (IS_USING_NEW_BINARY) {\n        // delete the legacy channel from AsyncStorage so this codepath isn't triggered anymore\n        _legacyDeleteChannel(nativeNotification.channelId);\n        return ExponentNotifications.scheduleLocalNotificationWithChannel(\n          nativeNotification,\n          options,\n          _channel\n        );\n      } else {\n        // TODO: remove this codepath before releasing, it will never be triggered on SDK 28+\n        // channel does not actually exist, so add its settings to the individual notification\n        if (_channel) {\n          nativeNotification.sound = _channel.sound;\n          nativeNotification.priority = _channel.priority;\n          nativeNotification.vibrate = _channel.vibrate;\n        }\n        return ExponentNotifications.scheduleLocalNotification(nativeNotification, options);\n      }\n    }\n  },\n\n  /* Dismiss currently shown notification with ID (Android only) */\n  async dismissNotificationAsync(notificationId: LocalNotificationId): Promise<void> {\n    if (!ExponentNotifications.dismissNotification) {\n      throw new UnavailabilityError('Expo.Notifications', 'dismissNotification');\n    }\n    return await ExponentNotifications.dismissNotification(notificationId);\n  },\n\n  /* Dismiss all currently shown notifications (Android only) */\n  async dismissAllNotificationsAsync(): Promise<void> {\n    if (!ExponentNotifications.dismissAllNotifications) {\n      throw new UnavailabilityError('Expo.Notifications', 'dismissAllNotifications');\n    }\n    return await ExponentNotifications.dismissAllNotifications();\n  },\n\n  /* Cancel scheduled notification notification with ID */\n  cancelScheduledNotificationAsync(notificationId: LocalNotificationId): Promise<void> {\n    if (Platform.OS === 'android' && typeof notificationId === 'string') {\n      return ExponentNotifications.cancelScheduledNotificationWithStringIdAsync(notificationId);\n    }\n    return ExponentNotifications.cancelScheduledNotificationAsync(notificationId);\n  },\n\n  /* Cancel all scheduled notifications */\n  cancelAllScheduledNotificationsAsync(): Promise<void> {\n    return ExponentNotifications.cancelAllScheduledNotificationsAsync();\n  },\n\n  /* Primary public api */\n  addListener(listener: (notification: Notification) => unknown): EventSubscription {\n    _maybeInitEmitter();\n\n    if (_initialNotification) {\n      const initialNotification = _initialNotification;\n      _initialNotification = null;\n      setTimeout(() => {\n        emitNotification(initialNotification);\n      }, 0);\n    }\n\n    return _emitter.addListener('notification', listener);\n  },\n\n  async getBadgeNumberAsync(): Promise<number> {\n    if (!ExponentNotifications.getBadgeNumberAsync) {\n      return 0;\n    }\n    return ExponentNotifications.getBadgeNumberAsync();\n  },\n\n  async setBadgeNumberAsync(number: number): Promise<void> {\n    if (!ExponentNotifications.setBadgeNumberAsync) {\n      throw new UnavailabilityError('Expo.Notifications', 'setBadgeNumberAsync');\n    }\n    return ExponentNotifications.setBadgeNumberAsync(number);\n  },\n\n  async scheduleNotificationWithCalendarAsync(\n    notification: LocalNotification,\n    options: {\n      year?: number;\n      month?: number;\n      hour?: number;\n      day?: number;\n      minute?: number;\n      second?: number;\n      weekDay?: number;\n      repeat?: boolean;\n    } = {}\n  ): Promise<string> {\n    const areOptionsValid: boolean =\n      (options.month == null || isInRangeInclusive(options.month, 1, 12)) &&\n      (options.day == null || isInRangeInclusive(options.day, 1, 31)) &&\n      (options.hour == null || isInRangeInclusive(options.hour, 0, 23)) &&\n      (options.minute == null || isInRangeInclusive(options.minute, 0, 59)) &&\n      (options.second == null || isInRangeInclusive(options.second, 0, 59)) &&\n      (options.weekDay == null || isInRangeInclusive(options.weekDay, 1, 7)) &&\n      (options.weekDay == null || options.day == null);\n\n    if (!areOptionsValid) {\n      throw new CodedError(\n        'WRONG_OPTIONS',\n        'Options in scheduleNotificationWithCalendarAsync call were incorrect!'\n      );\n    }\n\n    _validateNotification(notification);\n    const nativeNotification = _processNotification(notification);\n\n    return ExponentNotifications.scheduleNotificationWithCalendar(nativeNotification, options);\n  },\n\n  async scheduleNotificationWithTimerAsync(\n    notification: LocalNotification,\n    options: {\n      interval: number;\n      repeat?: boolean;\n    }\n  ): Promise<string> {\n    if (options.interval < 1) {\n      throw new CodedError('WRONG_OPTIONS', 'Interval must be not less then 1');\n    }\n\n    _validateNotification(notification);\n    const nativeNotification = _processNotification(notification);\n\n    return ExponentNotifications.scheduleNotificationWithTimer(nativeNotification, options);\n  },\n};\n\nfunction isInRangeInclusive(variable: number, min: number, max: number): boolean {\n  return variable >= min && variable <= max;\n}\n"]},"metadata":{},"sourceType":"module"}